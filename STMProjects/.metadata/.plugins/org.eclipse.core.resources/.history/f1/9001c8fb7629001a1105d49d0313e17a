/*
 * SignalAdjuster.h
 *
 *  Created on: Dec 27, 2019
 *      Author: dot
 */

#ifndef INC_SIGNALADJUSTER_H_
#define INC_SIGNALADJUSTER_H_
#include "main.h"
#include<stdint.h>
#include<math.h>
#define SIGNAL_SINE 'a'
#define SIGNAL_COSINE 'b'
#define SIGNAL_TANGENT 'c'
#define SIGNAL_RANDOM 'd'
#define NUM_SAMPLES 1024

void c_putSignalToDAC(void*v);
void c_execute(void*v);

class SignalAdjuster{
private:
	uint32_t signalType;
	uint32_t signalBuffer[NUM_SAMPLES];
	char signal;
	float amplitude;
	float frequency;
	float offset;
	uint32_t numberOfQuantizationLevels;
	float amplitudePerLevel;
	uint32_t sampleIndex;

	void increaseAmplitude();
	void decreaseAmplitude();
	void increaseFrequency();
	void decreaseFrequency();
	void previousSignal();
	void nextSignal();
	void sample();
	void configureTimer();
	uint32_t quantize(float v);



public:
	SignalAdjuster(float amplitude, float frequency, float offset, uint32_t numberOfQuantizationLevels, float amplitudePerLevel, uint32_t startSampleIndex) :amplitude(amplitude), frequency(frequency), offset(offset), numberOfQuantizationLevels(numberOfQuantizationLevels), amplitudePerLevel(amplitudePerLevel), sampleIndex(startSampleIndex) {
		tim1_callback = c_putSignalToDAC;
		usart2_rxne_callback = c_execute;
	};

	void execute(char cmd){
			switch(cmd){
				case 'i':increaseAmplitude();
				break;
				case 'k':decreaseAmplitude();
				break;
				case 'j':increaseFrequency();
				break;
				case'l':decreaseFrequency();
				break;
				case't':nextSignal();
				break;
				case'r':previousSignal();
			}
		}

		uint32_t getNextSample(){
			uint32_t ret = signalBuffer[sampleIndex];
			++sampleIndex;
			sampleIndex %= NUM_SAMPLES;
			return ret;
		}
};


#endif /* INC_SIGNALADJUSTER_H_ */
